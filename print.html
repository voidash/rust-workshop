<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>KUOSC Rust Workshop</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="why_rust.html"><strong aria-hidden="true">2.</strong> Why Rust?</a></li><li class="chapter-item expanded "><a href="Installing_Rust.html"><strong aria-hidden="true">3.</strong> Installing Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setting_up.html"><strong aria-hidden="true">3.1.</strong> Setting Up Editors and Extensions</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="dissect-hello-world.html"><strong aria-hidden="true">3.3.</strong> Understanding Hello world</a></li></ol></li><li class="chapter-item expanded "><a href="c-dilemma.html"><strong aria-hidden="true">4.</strong> Comparing with C</a></li><li class="chapter-item expanded "><a href="tour_of_rust.html"><strong aria-hidden="true">5.</strong> Tour of Rust</a></li><li class="chapter-item expanded "><a href="stack-vs-heap.html"><strong aria-hidden="true">6.</strong> Stack vs Heap</a></li><li class="chapter-item expanded "><a href="ownership-and-borrow-check.html"><strong aria-hidden="true">7.</strong> Ownership and Borrow Checker</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Work in Progress</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">KUOSC Rust Workshop</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <center><img width="100" src="https://voidash.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F5879eef3-18ea-4bbc-bd29-f5fd2e827242%2F1290b133-91e7-4d04-959c-7d327da6e137%2FDALLE_2023-11-06_23.28.05_-_A_logo_design_for_a_Rust_workshop_happening_at_Kathmandu_University._The_logo_features_the_Rust_programming_language_logo_a_stylized_gear_with_a_R_.png?table=block&id=298cc6b5-d380-42bc-81cf-73bd336b6f9c&spaceId=5879eef3-18ea-4bbc-bd29-f5fd2e827242&width=250&userId=&cache=v2">
<h1 id="rust-workshop"><a class="header" href="#rust-workshop">Rust Workshop </a></h1>
</center>
<p>This is the official book for the rust workshop happening at Kathmandu University. Here you will find written guides for all the stuff we talk on the sessions.</p>
<ul>
<li><a href="https://discord.gg/caNvvqMf46">Discord Invitation</a></li>
<li><a href="https://voidash.notion.site/Rust-workshop-298cc6b5d38042bc81cf73bd336b6f9c">Notion Link</a></li>
<li><a href="https://github.com/voidash/rust-workshop">GitHub link</a></li>
</ul>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<ul>
<li>Get started by installing Rust. Head to <a href="./Installing_Rust.html">Installing Rust</a></li>
<li>Each session will also have video, but it will be in Nepali</li>
</ul>
<blockquote>
<p>WIP, the goal of the workshop might change as the workshop moves forward</p>
</blockquote>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://lborb.github.io/book/official.html">Rust books maintained by the rust-lang.org </a></li>
<li><a href="https://github.com/rust-unofficial/awesome-rust">Awesome Rust</a></li>
<li><a href="https://doc.rust-lang.org/book/">Book of Rust</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a></li>
<li><a href="https://www.youtube.com/@jonhoo">Videos by Jon Gjengset</a></li>
</ul>
<h3 id="introductory-rust-resources-for-javascript-developers"><a class="header" href="#introductory-rust-resources-for-javascript-developers">Introductory Rust Resources For Javascript Developers</a></h3>
<ul>
<li><a href="https://www.sheshbabu.com/posts/rust-for-javascript-developers-tooling-ecosystem-overview/">Rust for Javascript Developers blog series</a></li>
<li><a href="https://tndl.me/blog/2020/rust-javascript-cheatsheet/">Rust For javascript Developers Cheatsheet</a></li>
</ul>
<h3 id="introductory-rust-resources-for-python-developers"><a class="header" href="#introductory-rust-resources-for-python-developers">Introductory Rust Resources For Python Developers</a></h3>
<ul>
<li><a href="https://lucumr.pocoo.org/2015/5/27/rust-for-pythonistas/">Rust for python Developers</a></li>
</ul>
<h3 id="embedded-resources"><a class="header" href="#embedded-resources">Embedded Resources</a></h3>
<ul>
<li><a href="https://apollolabsblog.hashnode.dev/edge-iot-with-rust-on-esp-ntp">Edge IoT with Rust</a></li>
<li><a href="https://mabez.dev/blog/posts/esp-rust-17-10-2022/">Esp Rust state </a></li>
<li><a href="https://readrust.net/">ReadRust</a></li>
</ul>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<ul>
<li><a href="http://venge.net/graydon/talks/intro-talk-2.pdf">The first slide deck, Graydon hoare presented </a></li>
<li><a href="https://dev.to/rimutaka/cargo-features-explained-with-examples-194g">Cargo Features explained</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="what-is-rust"><a class="header" href="#what-is-rust">What is Rust?</a></h2>
<ul>
<li>For Systems Programming</li>
<li>Targets the same use cases as C/C++ and more</li>
<li>Compiled Language (uses LLVM-IR)</li>
<li>Static Typed Language</li>
<li>Supports many platforms
<ul>
<li>x86, ARM, WebAssembly, RISC-V</li>
</ul>
</li>
<li>Can be used in Desktops, mobiles, routers, servers, etc.</li>
</ul>
<p><a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">Platform Support</a></p>
<h2 id="selling-points-of-rust"><a class="header" href="#selling-points-of-rust">Selling Points of Rust</a></h2>
<ul>
<li>Good Tooling</li>
<li>Great compiler errors</li>
<li>Built-in support for testing</li>
<li>Nice LSP (Language Server Protocol)</li>
<li>Cargo: The Rust package Manager and Build system</li>
</ul>
<h2 id="memory-safety"><a class="header" href="#memory-safety">Memory Safety</a></h2>
<ul>
<li>Ensures safety through compiler enforcement</li>
<li>No null pointers, no dangling pointers</li>
<li>No data races in concurrent situations inside safe code</li>
<li>Concept of ownership and borrowing ensures memory safety at compile time</li>
</ul>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<ul>
<li>Resources managed through RAII (Resource Acquisition Is Initialization)</li>
<li>Explicit heap allocation with 'Box'</li>
</ul>
<p><a href="https://deepu.tech/memory-management-in-rust/">More on Memory Management</a></p>
<h2 id="rust-code-examples"><a class="header" href="#rust-code-examples">Rust Code Examples</a></h2>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello world&quot;);
}</code></pre></pre>
<h3 id="fizzbuzz"><a class="header" href="#fizzbuzz">FizzBuzz</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for num in 1..=100 {
        match (num % 3, num % 5) {
            (0, 0) =&gt; println!(&quot;FizzBuzz&quot;),
            (0, _) =&gt; println!(&quot;Fizz&quot;),
            (_, 0) =&gt; println!(&quot;Buzz&quot;),
            _ =&gt; println!(&quot;{}&quot;, num),
        }
    }
}</code></pre></pre>
<h3 id="rust-vs-c"><a class="header" href="#rust-vs-c">Rust vs. C++</a></h3>
<p>The following C++ code compiles but it doesn't work as intended. can you guess the output?</p>
<ul>
<li>
<p>C++ Code</p>
<pre><code class="language-cpp">#include &lt;iostream&gt; 
#include &lt;vector&gt;
#include &lt;string&gt;

int main() {
    std::vector&lt;std::string&gt; data;
    data.push_back(&quot;hello&quot;);
    std::string &amp;adt = data[0];
    data.push_back(&quot;world&quot;);
    std::cout &lt;&lt; adt;
    return 0;
}
</code></pre>
<p>If you went through the code then one thing you will see is that the output is blank. The main reason is that <code>std::vector</code> which is a dynamically sized array. We haven't explicitly provided the size nor the contents for the vector so it starts with size of <code>1</code>. As you start adding more than one items in array, the array has to be resized. Vector in C++ resizes by creating a new array with size greater than the current one, and then copies the contents of existing array to new one. <code>&amp;adt</code> stores the reference to the first element in the array, However line below it causes the array to resized. The resizing operation causes the internal array address to be changed, as the existing array is copied to new array with bigger size, and the existing array contents are deleted. This means the address that <code>adt</code> holds, if you dereference it, it will contain nothing. So the output will be <strong>blank</strong></p>
</li>
<li>
<p>Rust Equivalent</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut data: Vec&lt;&amp;str&gt; = Vec::new();
    data.push(&quot;Hello&quot;);
    let adt = &amp;data[0];
    data.push(&quot;World&quot;);
    println!(&quot;{adt}&quot;);
}</code></pre></pre>
<p>This code doesn't compile on Rust, because if you have a reference to something and if you try to modify the content before discarding the reference then the reference might not be memory safe so Rust doesn't allow you. </p>
</li>
</ul>
<h2 id="advanced-topics-in-rust"><a class="header" href="#advanced-topics-in-rust">Advanced Topics in Rust</a></h2>
<ul>
<li>Move Semantics</li>
<li>Borrowing and Borrow Checker</li>
<li>Algebraic Data Types / Enums</li>
<li>Zero Cost Abstraction</li>
<li>Pattern Matching</li>
<li>Generics</li>
<li>Safe and correct memory management, without a garbage collector</li>
</ul>
<h2 id="rust-build-system-and-package-manager"><a class="header" href="#rust-build-system-and-package-manager">Rust Build System and Package Manager</a></h2>
<ul>
<li>Cargo Commands</li>
<li>Scalar Types</li>
<li>Compound Types</li>
</ul>
<h2 id="rust-in-action"><a class="header" href="#rust-in-action">Rust in Action</a></h2>
<ul>
<li>Writing an OS in Rust: <a href="https://os.phil-opp.com/">Phil-Opp's Blog</a></li>
<li>Kernel Driver with Rust: <a href="https://not-matthias.github.io/posts/kernel-driver-with-rust/">Kernel Driver Tutorial</a></li>
</ul>
<h2 id="real-world-rust-projects"><a class="header" href="#real-world-rust-projects">Real World Rust Projects</a></h2>
<ul>
<li>Tor's implementation in Rust (&quot;arti&quot;)</li>
<li>Dropbox's file sync engine</li>
<li>Figma's Multiplayer Server</li>
<li>Coursera's grading Server</li>
</ul>
<h2 id="rust-as-a-system-language"><a class="header" href="#rust-as-a-system-language">Rust as a System Language</a></h2>
<ul>
<li>Low level control
<ul>
<li>Unsafe blocks</li>
<li>Foreign function interface</li>
<li>Inline assembly</li>
</ul>
</li>
<li>Zero Cost abstractions</li>
<li>Pointer Types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Click the guide depending on the operating system you use</p>
<ul>
<li><a href="Installing_Rust.html#windows">Installing on Windows</a></li>
<li><a href="Installing_Rust.html#linux">Installing on Linux and Mac</a></li>
</ul>
<p>If you face any problem while installing, you can ask on discord, or google</p>
<h2 id="windows"><a class="header" href="#windows">Installing Rust on Windows</a></h2>
<h3 id="step-1-download-and-run-the-installer"><a class="header" href="#step-1-download-and-run-the-installer">Step 1: Download and Run the Installer</a></h3>
<ol>
<li>Go to the official Rust website: <a href="https://www.rust-lang.org/">https://www.rust-lang.org/</a>.</li>
<li>Click on the &quot;Install&quot; button.</li>
<li>Download the Windows installer (usually a <code>.exe</code> file).</li>
</ol>
<h3 id="step-2-run-the-installer"><a class="header" href="#step-2-run-the-installer">Step 2: Run the Installer</a></h3>
<ol start="4">
<li>Run the installer you downloaded.</li>
<li>Follow the installation prompts. You can choose the default settings for most options.</li>
</ol>
<h3 id="step-3-verify-the-installation"><a class="header" href="#step-3-verify-the-installation">Step 3: Verify the Installation</a></h3>
<ol start="6">
<li>Open a Command Prompt or Powershell window.</li>
<li>Type <code>rustc --version</code> and press Enter. You should see the Rust version number, indicating a successful installation.</li>
</ol>
<p><a href="https://www.youtube.com/watch?v=92HoSWgsx-4">Install Rust on Windows without Installing Visual C++ Build Tools</a></p>
<h2 id="linux"><a class="header" href="#linux">Installing Rust on Linux and Mac OS</a></h2>
<h3 id="step-1-install-rust-via-rustup-recommended"><a class="header" href="#step-1-install-rust-via-rustup-recommended">Step 1: Install Rust via Rustup (Recommended)</a></h3>
<ol>
<li>
<p>Open a Terminal.</p>
</li>
<li>
<p>Run the following command to download and install Rust using Rustup:</p>
</li>
<li>
<p><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></p>
</li>
</ol>
<h3 id="step-2-follow-the-installation-prompts"><a class="header" href="#step-2-follow-the-installation-prompts">Step 2: Follow the Installation Prompts</a></h3>
<ol start="3">
<li>Follow the prompts to customize your Rust installation if needed. The default options are usually fine.</li>
</ol>
<h3 id="step-3-configure-rust-environment"><a class="header" href="#step-3-configure-rust-environment">Step 3: Configure Rust Environment</a></h3>
<ol start="4">
<li>
<p>After installation, Rustup will provide instructions for setting up your environment. Follow these instructions. It typically involves running a command like:</p>
<p>bash</p>
</li>
<li>
<p><code>source $HOME/.cargo/env</code></p>
</li>
</ol>
<h3 id="step-4-verify-the-installation"><a class="header" href="#step-4-verify-the-installation">Step 4: Verify the Installation</a></h3>
<ol start="5">
<li>In the Terminal, type <code>rustc --version</code> and press Enter. You should see the Rust version number, confirming a successful installation.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>If you haven't set up editor yet, then i suggest you to download Visual studio Code(VSCode). Download it from their website  https://code.visualstudio.com/ 
Once downloaded here is how you set it up for Rust.</p>
<h3 id="setting-up-editor-for-vscode"><a class="header" href="#setting-up-editor-for-vscode">Setting up Editor for Vscode</a></h3>
<ul>
<li><strong>Install  Rust Analyzer Extension</strong> </li>
</ul>
<p><img src="assets/2023-11-20-23-03-35.png" alt="" /> </p>
<ul>
<li>Open VSCode.</li>
<li>Go to the Extensions view by clicking on the Extensions icon in the sidebar or pressing <code>Ctrl+Shift+X</code>.</li>
<li>Search for &quot;<em><strong>rust-analyzer</strong></em>&quot; in the Extensions Marketplace.</li>
<li>Install the extension</li>
</ul>
<p>Rust analyzer has features like code completion, goto definition, finding references , inlay hinting that makes your editor a Rust Development Environment</p>
<ul>
<li>
<p>Other extensions you can install</p>
<ul>
<li><strong>Rust Syntax</strong> : Better Rust syntax highlighting</li>
</ul>
<p><img src="assets/2023-11-20-23-05-57.png" alt="" /></p>
<ul>
<li><strong>Crates</strong> : Makes Managing dependencies easier</li>
</ul>
<p><img src="assets/2023-11-20-23-06-15.png" alt="" /></p>
<ul>
<li><strong>CodeLLDB</strong> : To debug Rust code</li>
</ul>
<p><img src="assets/2023-11-20-23-04-42.png" alt="" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><strong>Create a New Project:</strong></p>
<ul>
<li>
<p>In Rust, projects are organized into packages and crates. You can start by creating a new Rust project using the <code>cargo</code> tool, which comes with Rust.</p>
</li>
<li>
<p>Open your terminal and navigate to the directory where you want to create your project. If you are on windows then use <code>powershell</code></p>
<p><code>cargo new hello_world</code></p>
<p>This command will create a new directory called <code>hello_world</code> with the necessary project structure.</p>
</li>
<li>
<p><strong>Edit the Main File:</strong></p>
<ul>
<li>Navigate into the <code>hello_world</code> directory:</li>
</ul>
</li>
</ul>
<p><code>cd hello_world</code></p>
<ul>
<li>
<p>Inside this directory, you'll find a file named <code>main.rs</code>. Open this file in a text editor of your choice. If you use vscode, then you can open the folder in vscode from terminal with <code>code .</code></p>
</li>
<li>
<p>Replace the existing code with the following Hello program:</p>
</li>
</ul>
<pre><code>fn main() {     
	println!(&quot;Hello, 🇳🇵!&quot;);
}
</code></pre>
<pre><code>This code defines a `main` function, which is the entry point of your Rust program. It uses the `println!` macro to print &quot;Hello, 🇳🇵!&quot; to the console.
</code></pre>
<ul>
<li>
<p><strong>Build and Run:</strong></p>
<ul>
<li>Now, you can build and run your Rust program using <code>cargo</code>. In your terminal, run:
<code>cargo run</code></li>
</ul>
<p>This command will compile and execute your Rust program. You should see the output &quot;Hello, 🇳🇵!&quot; displayed in the terminal.</p>
</li>
</ul>
<p>This simple program confirms that your Rust development environment is set up correctly and ready for more advanced development. </p>
<div style="break-before: page; page-break-before: always;"></div><p><code>fn main() {     println!(&quot;Hello, World!&quot;); }</code></p>
<ol>
<li>
<p><strong><code>fn main() { ... }</code>:</strong> This is the entry point of the Rust program. In Rust, every program must have a <code>main</code> function. When you run your program, the code inside <code>main</code> is executed first.</p>
</li>
<li>
<p><strong><code>println!(&quot;Hello, World!&quot;);</code>:</strong> This is the main part of the program that prints the &quot;Hello, World!&quot; message to the console. Here's what's happening here:</p>
<ul>
<li>
<p><code>println!</code>: This is a Rust macro for printing text to the console. Macros in Rust are like functions but with an exclamation mark (<code>!</code>) at the end.</p>
</li>
<li>
<p><code>&quot;Hello, World!&quot;</code>: This is the message that the <code>println!</code> macro will print. It's enclosed in double quotes to indicate that it's a string of characters.</p>
</li>
<li>
<p><code>;</code> (semicolon): This is the statement terminator in Rust, indicating the end of this line of code. Rust uses semicolons to separate statements.</p>
</li>
</ul>
</li>
</ol>
<p>So, when you run the program, the <code>main</code> function is called, and it, in turn, calls <code>println!(&quot;Hello, World!&quot;);</code>, which prints &quot;Hello, World!&quot; to the console.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Extracted from : https://google.github.io/comprehensive-rust/why-rust/an-example-in-c.html</p>
<p>Here is the C code with many bugs. Try finding it</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;

int main(int argc, char* argv[]) {
	char *buf, *filename;
	FILE *fp;
	size_t bytes, len;
	struct stat st;

	switch (argc) {
		case 1:
			printf(&quot;Too few arguments!\n&quot;);
			return 1;

		case 2:
			filename = argv[argc];
			stat(filename, &amp;st);
			len = st.st_size;
			
			buf = (char*)malloc(len);
			if (!buf)
				printf(&quot;malloc failed!\n&quot;, len);
				return 1;

			fp = fopen(filename, &quot;rb&quot;);
			bytes = fread(buf, 1, len, fp);
			if (bytes = st.st_size)
				printf(&quot;%s&quot;, buf);
			else
				printf(&quot;fread failed!\n&quot;);

		case 3:
			printf(&quot;Too many arguments!\n&quot;);
			return 1;
	}

	return 0;
}

</code></pre>
<p>Can you find all the bugs? There are 11 of them</p>
<ol>
<li>Assignment <code>=</code> instead of equality comparison <code>==</code> (line 28)</li>
<li>Excess argument to <code>printf</code> (line 23)</li>
<li>File descriptor leak (after line 26)</li>
<li>Forgotten braces in multi-line <code>if</code> (line 22)</li>
<li>Forgotten <code>break</code> in a <code>switch</code> statement (line 32)</li>
<li>Forgotten NUL-termination of the <code>buf</code> string, leading to a buffer overflow (line 29)</li>
<li>Memory leak by not freeing the <code>malloc</code>-allocated buffer (line 21)</li>
<li>Out-of-bounds access (line 17)</li>
<li>Unchecked cases in the <code>switch</code> statement (line 11)</li>
<li>Unchecked return values of <code>stat</code> and <code>fopen</code> (lines 18 and 26)</li>
</ol>
<p>try copying and running it online on <a href="https://www.onlinegdb.com/online_c_compiler">online GDB</a>. It will compile fine. But these are all serious bugs, how come the compiler accepts just like that.... and these errors are serious</p>
<ul>
<li>Assignment <code>=</code> instead of equality comparison <code>==</code>: <a href="https://freedom-to-tinker.com/2013/10/09/the-linux-backdoor-attempt-of-2003">The Linux Backdoor Attempt of 2003</a></li>
<li>Forgotten braces in multi-line <code>if</code>: <a href="https://dwheeler.com/essays/apple-goto-fail.html">The Apple goto fail vulnerability</a></li>
<li>Forgotten <code>break</code> in a <code>switch</code> statement: <a href="https://www.lufsec.com/anatomy-of-a-security-hole-the-break-that-broke-sudo/">The break that broke sudo</a></li>
</ul>
<h3 id="how-can-rust-be-better-here"><a class="header" href="#how-can-rust-be-better-here">How can Rust be better here?</a></h3>
<ol>
<li>Assignments inside an <code>if</code> clause are not supported.</li>
<li>Format strings are checked at compile-time.</li>
<li>Resources are freed at the end of scope via the <code>Drop</code> trait.</li>
<li>All <code>if</code> clauses require braces.</li>
<li><code>match</code> (as the Rust equivalent to <code>switch</code>) does not fall-through, hence you can’t accidentally forget a <code>break</code>.</li>
<li>Buffer slices carry their size and don’t rely on a NUL terminator.</li>
<li>Heap-allocated memory is freed via the <code>Drop</code> trait when the corresponding <code>Box</code> leaves the scope.</li>
<li>Out-of-bounds accesses cause a panic or can be checked via the <code>get</code> method of a slice.</li>
<li><code>match</code> mandates that all cases are handled.</li>
<li>Fallible Rust functions return <code>Result</code> values that need to be unwrapped and thereby checked for success. Additionally, the compiler emits a warning if you miss to check the return value of a function marked with <code>#[must_use]</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>Some snippets that will help you understand Rust code and some Rust fundamentals along the way</p>
<p><code>let</code> introduces variable binding.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 42; 
<span class="boring">}</span></code></pre></pre>
<p>Since Rust is statically typed language, which means you have to specify the type of variable. i.e if it is storing strings, or integers or floating numbers or your own data type</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let a: i32 = 12; // 32 bit integer 
let b: &amp;str = &quot;Hello nepal&quot;;  //str
let c: char = 'a'; //char
let d: bool = true;
let e: f32 = 3.1415;
let c: u32 = 32; //32 bit integer but you can't store negative numbers
<span class="boring">}</span></code></pre></pre>
<p>Rust can implicitly identify your variable type based upon the content you are passing to variable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 12; // automatically assigned to i32
<span class="boring">}</span></code></pre></pre>
<p>To print something to console, you just use </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello world&quot;);
<span class="boring">}</span></code></pre></pre>
<p>to print the contents of the variable you can</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let age : i32 = 21;
println!(&quot;Hello, my age is {}&quot;, age);
// or you can also 
println!(&quot;Hello, my age is {age}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Notice that exclamation mark at the end. it means it is <a href="Rust%20macros.html">Rust macros</a> . </p>
<p>Rust variables are immutable by default which means, you can't change the content of the variable once you assign something to it. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let age : i32 = 21;
age = 22; // error this won't work, because age is immutable
<span class="boring">}</span></code></pre></pre>
<p>You can shadow a variable bindings</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 17;
let x = &quot;awesome&quot;; // x is not mutable, but we re-binded it
<span class="boring">}</span></code></pre></pre>
<p>You can also use patterns to declare variables</p>
<pre><code>let (a,b) = (&quot;Nepal GPO sucks&quot;,12);
</code></pre>
<p>You have to explicitly use the keyword <code>mut</code> to make it re-assignable</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut age: i32 = 21;
age = 22; // valid because we used mut keyword
<span class="boring">}</span></code></pre></pre>
<p>Now similarly generate small snippets and information combination for
conditionals, loops, match, struct, vector, array, tuples and so on</p>
<h4 id="comments"><a class="header" href="#comments">Comments</a></h4>
<pre><code>/// Triple-slash comments are docstring comments.
///
/// `rustdoc` uses docstring comments to generate
/// documentation, and supports **Markdown** formatting.
fn foo() {
    // Double-slash comments are normal.

    /* Block comments
     * also exist /* and can be nested! */
     */
}
</code></pre>
<h4 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h4>
<p>In Rust, you can use <code>if</code>, <code>else if</code>, and <code>else</code> statements for conditionals.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 7;

if number &lt; 5 {
    println!(&quot;Condition is true&quot;);
} else if number == 7 {
    println!(&quot;Number is seven&quot;);
} else {
    println!(&quot;Condition is false&quot;);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="arrays"><a class="header" href="#arrays">Arrays</a></h4>
<ul>
<li>Arrays are generically of type <code>[T; N]</code>.
<ul>
<li>T is type, can be &amp;str, char, bool, i32 etc</li>
<li>N is a compile-time <em>constant</em>. Arrays cannot be resized.</li>
<li>Array access is bounds-checked at runtime.</li>
</ul>
</li>
<li>Arrays are indexed with <code>[]</code> 
<ul>
<li><code>arr[3]</code> gives you the 4th element of <code>arr</code></li>
</ul>
</li>
</ul>
<pre><code>let arr1 = [1, 2, 3]; // (array of 3 elements)
let arr2 = [2; 32];   // (array of 32 `2`s)
let arr2: [u8;4] = [12,32,73,11]; // (array of 4 8-bit integers that can only accept positive numbers)
</code></pre>
<h4 id="slices"><a class="header" href="#slices">Slices</a></h4>
<p>You create a slice of array and it is in format &amp;[T]. They are reference to your arrays, and you can take specific section of your arrays with slices too. </p>
<pre><code>let arr = [0, 1, 2, 3, 4, 5];
let total_slice = &amp;arr;         // Slice all of `arr`
let total_slice = &amp;arr[..];     // Same, but more explicit
let partial_slice = &amp;arr[2..5]; // [2, 3, 4]
</code></pre>
<h4 id="strings"><a class="header" href="#strings">Strings</a></h4>
<p>There are two types of strings.<code>String</code> and <code>&amp;str</code>. Strings are growable set of characters. Basically you can think of it as dynamic array of characters. <code>&amp;str</code> is the slice of <code>String</code> which means they are fixed. For more information look to <a href="stack%20vs%20heap.html">stack vs heap</a>, to understand the difference between String and &amp;str. </p>
<p>When you use literals in your program, compiler automatically assumes it is of type <code>&amp;str</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = &quot;Nepal's General post office is why i hate government work&quot;;
// this is of type &amp;str 

let b = String::from(&quot;Foo&quot;); //this is of type String
let s4: &amp;str = &amp;b; 
<span class="boring">}</span></code></pre></pre>
<h4 id="vector"><a class="header" href="#vector">Vector</a></h4>
<p><code>Vec&lt;T&gt;</code> are resizable arrays. <code>&lt;T&gt;</code> denotes the generic type, so we pass the type from there. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v: Vec&lt;i32&gt; = Vec::new(); // Declare a new vector

v.push(5);
v.push(6);
v.push(7);
<span class="boring">}</span></code></pre></pre>
<p>Shortcut method to create vector</p>
<pre><code>let v2 = vec![1,2,3];
</code></pre>
<p>Vectors can be indexed with <code>[]</code>, but you have to use <code>usize</code>.</p>
<pre><code>let v2 = vec![1,2,3];
let i: u8 = 2;
// let d = v2[i]; // error as i should be of type usize
let d = v2[i as usize]; // casting
</code></pre>
<h4 id="loops"><a class="header" href="#loops">Loops</a></h4>
<p>Rust provides several types of loops, including <code>loop</code>, <code>while</code>, and <code>for</code>.</p>
<p>Infinite Loop</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    println!(&quot;This will loop forever until explicitly broken!&quot;);
    break; // Use break to exit the loop
}
<span class="boring">}</span></code></pre></pre>
<h4 id="while-loop"><a class="header" href="#while-loop">While Loop</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut count = 0;

while count &lt; 5 {
    println!(&quot;count: {}&quot;, count);
    count += 1;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="for-loop"><a class="header" href="#for-loop">For Loop</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for number in 1..4 { // 1..4 is a range (1,2,3)
    println!(&quot;number: {}&quot;, number);
	// you can break and continue too
}

<span class="boring">}</span></code></pre></pre>
<p>notice that <code>1..4</code>. It is a range. The syntax is <code>start..end</code> , Some operation on ranges</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	// including all the endpoints of range
	let include_all = (1..=4); // 1,2,3,4 

	// reversing
	let reversed = (1..4).rev(); // 3,2,1

	// convert range to vector
	let numbers = (1..4).collect::&lt;i32&gt;(); // collect 1,2,3,4 as 32 bit integer 
	// or
	let numbers: Vec&lt;i32&gt; = (1..4).collect();

	//skip
	let skipped_val = (1..10).skip(2);  //1,3,5,7,9

	// explore enumerate(), iter(), take() by yourself
<span class="boring">}</span></code></pre></pre>
<h2 id="everything-is-expressions-almost"><a class="header" href="#everything-is-expressions-almost">Everything is expressions (almost)</a></h2>
<p>Expressions return a value. So Expressions are something that returns value, can't get simpler than that.<br />
We can bind many things to variable name, because everything is expression. The rule is, if it's expression then we can bind it to a variable.</p>
<pre><code>let x = -5;
let y = if x &gt; 0 { &quot;greater&quot; } else { &quot;less&quot; };
println!(&quot;x = {} is {} than zero&quot;, x, y);
</code></pre>
<h4 id="struct"><a class="header" href="#struct">Struct</a></h4>
<p>Structs are used to create custom data types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

let user1 = User {
    email: String::from(&quot;coldplay@gmail.com&quot;),
    username: String::from(&quot;yellow&quot;),
    active: true,
    sign_in_count: 1,
};
<span class="boring">}</span></code></pre></pre>
<h4 id="tuples"><a class="header" href="#tuples">Tuples</a></h4>
<p>Tuples are fixed-size collections of multiple types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, f64, u8) = (500, 6.4, 1);

let (x, y, z) = tup; // Destructuring

println!(&quot;The value of y is: {}&quot;, y);
<span class="boring">}</span></code></pre></pre>
<h4 id="functions"><a class="header" href="#functions">Functions</a></h4>
<p>Functions in Rust are defined using the <code>fn</code> keyword, with typed parameters and an optional return type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn square(n: i32) -&gt; i32 {
    n * n // no need to type return 
    // if there is no semicolon at the end then it means it returns that value
}

fn squareish(n: i32) -&gt; i32 {
    if n &lt; 5 { return n; } // if you want to return early then use return keyword
    n * n
}

fn greet(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}

greet(&quot;Alice&quot;);
<span class="boring">}</span></code></pre></pre>
<p>You can store functions in variable</p>
<pre><code>let x : fn(i32) -&gt; i32 = square;

fn do_it_two_times(f: &amp;fn(i32) -&gt; i32, x: i32 ) -&gt; i32 {
	f(f(x))
}

let y = do_it_two_times(&amp;square, 5);
</code></pre>
<h4 id="match"><a class="header" href="#match">Match</a></h4>
<p><code>match</code> is similar to switch cases in other languages, but more powerful.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 2;

match number {
    1 =&gt; println!(&quot;One&quot;),
    2 =&gt; println!(&quot;Two&quot;),
    3 =&gt; println!(&quot;Three&quot;),
    _ =&gt; println!(&quot;Anything else&quot;), // '_' is the default case
}
<span class="boring">}</span></code></pre></pre>
<p>you can match with range</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 13;

match number {
    1..=5 =&gt; println!(&quot;It's between 1 and 5&quot;),
    6..=10 =&gt; println!(&quot;It's between 6 and 10&quot;),
    _ =&gt; println!(&quot;It's something else&quot;),
}
<span class="boring">}</span></code></pre></pre>
<p>you can add guards to match</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 4;

match number {
    n if n % 2 == 0 =&gt; println!(&quot;Even number&quot;),
    n if n % 2 != 0 =&gt; println!(&quot;Odd number&quot;),
    _ =&gt; println!(&quot;It's something else&quot;),
}

<span class="boring">}</span></code></pre></pre>
<p>you can match with Enums too, see below examples</p>
<h4 id="enums"><a class="header" href="#enums">Enums</a></h4>
<p>Enums are a way to define a type by enumerating its possible values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Direction {
    Up,
    Down,
    Left,
    Right,
}

fn move_direction(direction: Direction) {
    match direction {
        Direction::Up =&gt; println!(&quot;Moving up&quot;),
        // Other directions...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Enums in Rust can also have data associated with their variants. This feature can be particularly useful for representing more complex scenarios like error handling or state management.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum AppState {
    Loading,
    Content(String),
    Error(String),
}

fn get_app_state(loading: bool, has_error: bool) -&gt; AppState {
    if loading {
        AppState::Loading
    } else if has_error {
        AppState::Error(String::from(&quot;An error occurred&quot;))
    } else {
        AppState::Content(String::from(&quot;Content loaded successfully&quot;))
    }
}

let state = get_app_state(false, true);

match state {
    AppState::Loading =&gt; println!(&quot;App is loading...&quot;),
    AppState::Content(content) =&gt; println!(&quot;Content: {}&quot;, content),
    AppState::Error(error) =&gt; println!(&quot;Error: {}&quot;, error),
}
<span class="boring">}</span></code></pre></pre>
<p>This example shows an <code>AppState</code> enum with different variants for loading, content, and error states. The <code>match</code> statement then handles each state accordingly.</p>
<p>Rust's <code>Option</code> and <code>Result</code> types are actually enums under the hood. Understanding the basic enum concept can help grasp these types better.</p>
<ul>
<li><code>Option&lt;T&gt;</code> can be either <code>Some(T)</code> or <code>None</code>.</li>
<li><code>Result&lt;T, E&gt;</code> can be either <code>Ok(T)</code> for success or <code>Err(E)</code> for an error.</li>
</ul>
<p>Here's a simplified version of how they might be defined:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; {
    if denominator == 0.0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

let result = divide(10.0, 2.0);
<span class="boring">}</span></code></pre></pre>
<p>As written above, <code>Result&lt;T, E&gt;</code> is used for error handling. It returns <code>Ok(value)</code> if successful, or <code>Err(error)</code> if an error occurs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_age(age: i32) -&gt; Result&lt;(), String&gt; {
    if age &gt;= 18 {
        Ok(())
    } else {
        Err(String::from(&quot;Underage&quot;))
    }
}

let age_check = check_age(20);
<span class="boring">}</span></code></pre></pre>
<h4 id="cargo"><a class="header" href="#cargo">Cargo</a></h4>
<ul>
<li>Create a new project:
<ul>
<li><code>cargo new project_name</code> (library)</li>
<li><code>cargo new project_name --bin</code> (executable)</li>
</ul>
</li>
<li>Build your project: <code>cargo build</code></li>
<li>Run your tests: <code>cargo test</code></li>
</ul>
<h4 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h4>
<ul>
<li>This is what Rust uses to manage dependencies and project metadata. When you open something like this is shown</li>
</ul>
<pre><code>[package]
name = &quot;my_project&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
serde = &quot;1.0&quot;
serde_json = &quot;1.0&quot;
log = &quot;0.4&quot;

</code></pre>
<ul>
<li>You add crates to your project as dependency</li>
</ul>
<pre><code>[dependencies] 
futures = &quot;0.3&quot; // name = version
</code></pre>
<ul>
<li><strong>Exact version</strong>: <code>&quot;1.2.3&quot;</code></li>
<li><strong>Caret version requirements</strong>: <code>&quot;^1.2.3&quot;</code> (default, compatible with public API version 1.2.3)</li>
<li><strong>Tilde version requirements</strong>: <code>&quot;~1.2.3&quot;</code> (version 1.2.3 and the versions up to 1.3.0, not including 1.3.0)</li>
<li><strong>Wildcard version requirements</strong>: <code>&quot;1.2.*&quot;</code> (any version that starts with 1.2)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-and-heap"><a class="header" href="#stack-and-heap">Stack and Heap</a></h1>
<p>These are memory constructs. There is no specific different hardware for Stack and Heap in RAM. How they are different is how stack and heap are structured in RAM. </p>
<p>Stack stores fixed sized data. Example:  i32 is a type in Rust which means signed 32 bit Integer. When you define a variable as i32, then it is stored on a stack because we know the max possible number of bits that it can use, i.e 32 bits. The size is known beforehand. 
This also means that fetching stuff from memory is fast. Allocation is fast. Deleting is fast becasue we know the size is not going to increase for that particular variable in stack.</p>
<p>and heap stores variable sized data. The size is not known beforehand. The size requirements may increase. So when program is running or during runtime, we must to be increase or decrease the size of that memory portion. Due to this accessing data in heap is slower.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>Any variable that binds some value to it takes ownership of that data. This basically means a peice of data can only have one owner at a time.</p>
<h4 id="ownership-is-rust-claim-to-fame"><a class="header" href="#ownership-is-rust-claim-to-fame">Ownership is Rust claim to fame</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    // Creates a Vec object.
    // Gives ownership of the Vec object to v1.
    let mut v1 = vec![1, 2, 3];

    v1.pop();
    v1.push(4);

    // At the end of the scope, v1 goes out of scope.
    // v1 still owns the Vec object, so it can be cleaned up.
}

<span class="boring">}</span></code></pre></pre>
<h2 id="why-discuss-ownership-in-the-first-place"><a class="header" href="#why-discuss-ownership-in-the-first-place">Why discuss ownership in the first place?</a></h2>
<p>If you boil down everything you do with a programming language , then all you do is define &quot;ways to interact with data&quot;. At the core, programming languages are different on the basis of syntax and how they handle your data, how much it trusts you with the data or it questions your memory management skills. The region where your data is stored is Memory. Some language like C++, C and Rust can give access low level access to Memory Region, whereas some languages like Javascript, Python can't provide you with same level of access because the memory management is not up to you. </p>
<ul>
<li>Languages like Java, Javascript use something called garbage collector which allows you instantiate or store data in memory but when it comes to cleaning it up once it is of no use then the garbage collector will help you cleaning up.</li>
</ul>
<h4 id="garbage-collection-is-expensive"><a class="header" href="#garbage-collection-is-expensive">Garbage collection is expensive.</a></h4>
<p>Garbage collector(<strong>GC</strong>) is also a piece of code, that cleans up your mess, which means when you build your executable file, the GC code also has to be included. It also has to check from time to time if certain data can be freed or not. That constant checking and cleaning is a overhead, that makes your program slow. The extra code that you include is also overhead that makes your program size large. </p>
<h2 id="manual-memory-management"><a class="header" href="#manual-memory-management">Manual Memory management</a></h2>
<p>programming languages like C, C++ allow you to do your manual memory management. It completely trusts the developer. But this introduces problems. When a piece of memory that needed to be freed is not freed then there is memory leakage. Or what if we delete a piece of memory before it is used? It will lead to Dangling pointers. those pointers will assume that they still have correct data in memory. It is not memory safe</p>
<h2 id="rust-to-the-rescue"><a class="header" href="#rust-to-the-rescue">Rust to the rescue</a></h2>
<p>Ownership is Rust’s most unique feature and has deep implications for the rest of the language. It enables Rust to make memory safety guarantees without needing a garbage collector, so it’s important to understand how ownership works.</p>
<h2 id="read-about-stack-vs-heap"><a class="header" href="#read-about-stack-vs-heap"><a href="./stack-vs-heap.html">Read about Stack vs Heap </a></a></h2>
<h2 id="compile-time-and-run-time"><a class="header" href="#compile-time-and-run-time">Compile Time and Run Time</a></h2>
<p>Compile time is when your code is being converted to executable format.
Runtime is when your executable is being run.</p>
<ul>
<li>When you introduce a variable binding, it takes ownership of its data. And a piece of data can only have one owner at a time.</li>
<li>When a variable binding goes out of scope, nothing has access to the data anymore, so it can be released. Which means, if it's on the heap, it can be de-allocated.</li>
<li>And data must be guaranteed to outlive its references. Or, all references are guaranteed to be valid.</li>
</ul>
<h2 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h2>
<pre><code>let v1 = vec![1, 2, 3];

// Ownership of the Vec object moves to v2.
let v2 = v1;

println!(&quot;{}&quot;, v1[2]); // error: use of moved value `v1`
</code></pre>
<ul>
<li>
<p><code>let v2 = v1;</code></p>
<ul>
<li>We don't want to copy the data, since that's expensive.</li>
<li>The data cannot have multiple owners.</li>
<li>Solution: move the Vec's ownership into v2, and declare v1 invalid.</li>
</ul>
</li>
<li>
<p><code>println!(&quot;{}&quot;, v1[2]);</code>
We know that v1 is no longer a valid variable binding, so this is an error.
Rust can reason about this at compile time, so it throws a compiler error.</p>
</li>
</ul>
<p>Here's another example:</p>
<ul>
<li>Line 1: declare a vector v1.</li>
<li>Line 2: let v2 = v1. Ownership of the vector is moved from v1 to v2.
<ul>
<li>we don't want to move or copy the data, that's expensive and causes other
bugs</li>
<li>we already know the data can't have multiple owners</li>
</ul>
</li>
<li>Line 3: try to print v1.
<ul>
<li>but since the vector has been moved out of v1, it is no longer a valid
variable binding</li>
</ul>
</li>
<li>all of this happens at compile time.</li>
</ul>
<hr />
<h2 id="move-semantics-1"><a class="header" href="#move-semantics-1">Move Semantics</a></h2>
<ul>
<li>
<p>Moving ownership is a compile-time semantic; it doesn't involve moving data
during your program.</p>
</li>
<li>
<p>Moves are automatic (via assignments); no need to use something like C++'s
<code>std::move</code>.</p>
<ul>
<li>However, there are functions like <code>std::mem::replace</code> in Rust to provide
advanced ownership management.</li>
</ul>
</li>
<li>
<p>Moving ownership is an impliict operation done at compile time. No data is
moved or copied around when your program is being run.</p>
</li>
<li>
<p>The movement of data is automatic, you don't need to call anything like
std::move (as in C++).</p>
</li>
<li>
<p>But you can do more fine-grained ownership or memory movement with a number of
standrard library functions, like std::mem::replace.</p>
</li>
</ul>
<hr />
<h2 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h2>
<ul>
<li>Ownership does not always have to be moved.</li>
<li>What would happen if it did? Rust would get very tedious to write:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn vector_length(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // Do whatever here,
    // then return ownership of `v` back to the caller
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>You could imagine that this does not scale well either.
<ul>
<li>The more variables you had to hand back, the longer your return type would be!</li>
<li>Imagine having to pass ownership around for 5+ variables at a time :(</li>
</ul>
</li>
</ul>
<p>???</p>
<ul>
<li>Ownership doesn't have to be moved.</li>
<li>If it did, you would also have to return ownership at the end of every
function, or have all of your variables constantly going out of scope.</li>
<li>This gets absurd very quickly, imagine having to return all of your function
arguments as return values just to make sure they don't go out of scope.</li>
</ul>
<hr />
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<ul>
<li>Obviously, this is not the case.</li>
<li>Instead of transferring ownership, we can <em>borrow</em> data.</li>
<li>A variable's data can be borrowed by taking a reference to the variable;
ownership doesn't change.
<ul>
<li>When a reference goes out of scope, the borrow is over.</li>
<li>The original variable retains ownership throughout.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

// v_ref is a reference to v.
let v_ref = &amp;v;

// use v_ref to access the data in the vector v.
assert_eq!(v[1], v_ref[1]);
<span class="boring">}</span></code></pre></pre>
<p>???</p>
<ul>
<li>Obviously, this is not the case in Rust, otherwise the language would be
impossible to use.</li>
<li>Instead, we can temporarily transfer ownership by borrowing data.</li>
<li>The way that borrowing works is: you can take a reference to the original
variable and use it to access the data.</li>
<li>When a reference goes out of scope, the borrow is over.</li>
<li>However, the original variable retains ownership during the borrow and
afterwards.</li>
</ul>
<hr />
<h2 id="borrowing-1"><a class="header" href="#borrowing-1">Borrowing</a></h2>
<ul>
<li>Caveat: this adds restrictions to the original variable.</li>
<li>Ownership cannot be transferred from a variable while references to it exist.
<ul>
<li>That would invalidate the reference.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

// v_ref is a reference to v.
let v_ref = &amp;v;

// Moving ownership to v_new would invalidate v_ref.
// error: cannot move out of `v` because it is borrowed
let v_new = v;
<span class="boring">}</span></code></pre></pre>
<p>???</p>
<ul>
<li>This adds a caveat: ownership cannot be ransferred <em>from</em> a variable that is
currently being borrowed, because that would invalidate the reference.</li>
</ul>
<hr />
<h2 id="borrowing-2"><a class="header" href="#borrowing-2">Borrowing</a></h2>
<pre><pre class="playground"><code class="language-rust">/// `length` only needs `vector` temporarily, so it is borrowed.
fn length(vec_ref: &amp;Vec&lt;i32&gt;) -&gt; usize {
    // vec_ref is auto-dereferenced when you call methods on it.
    vec_ref.len()
    // you can also explicitly dereference.
    // (*vec_ref).len()
}

fn main() {
    let vector = vec![];
    length(&amp;vector);
    println!(&quot;{:?}&quot;, vector); // this is fine
}</code></pre></pre>
<ul>
<li>Note the type of <code>length</code>: <code>vec_ref</code> is passed by reference, so it's now an <code>&amp;Vec&lt;i32&gt;</code>.</li>
<li>References, like bindings, are <em>immutable</em> by default.</li>
<li>The borrow is over after the reference goes out of scope (at the end of <code>length</code>).</li>
</ul>
<hr />
<h2 id="borrowing-3"><a class="header" href="#borrowing-3">Borrowing</a></h2>
<pre><pre class="playground"><code class="language-rust">/// `push` needs to modify `vector` so it is borrowed mutably.
fn push(vec_ref: &amp;mut Vec&lt;i32&gt;, x: i32) {
    vec_ref.push(x);
}

fn main() {
    let mut vector: Vec&lt;i32&gt; = vec![];
    let vector_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut vector;
    push(vector_ref, 4);
}</code></pre></pre>
<ul>
<li>Variables can be borrowed by <em>mutable</em> reference: <code>&amp;mut vec_ref</code>.
<ul>
<li><code>vec_ref</code> is a reference to a mutable <code>Vec</code>.</li>
<li>The type is <code>&amp;mut Vec&lt;i32&gt;</code>, not <code>&amp;Vec&lt;i32&gt;</code>.</li>
</ul>
</li>
<li>Different from a reference which is variable.</li>
</ul>
<hr />
<h2 id="borrowing-4"><a class="header" href="#borrowing-4">Borrowing</a></h2>
<pre><pre class="playground"><code class="language-rust">/// `push` needs to modify `vector` so it is borrowed mutably.
fn push2(vec_ref: &amp;mut Vec&lt;i32&gt;, x: i32) {
    // error: cannot move out of borrowed content.
    let vector = *vec_ref;
    vector.push(x);
}

fn main() {
    let mut vector = vec![];
    push2(&amp;mut vector, 4);
}</code></pre></pre>
<ul>
<li>Error! You can't dereference <code>vec_ref</code> into a variable binding because that
would change the ownership of the data.</li>
</ul>
<hr />
<h2 id="borrowing-5"><a class="header" href="#borrowing-5">Borrowing</a></h2>
<ul>
<li>Rust will auto-dereference variables...
<ul>
<li>When making method calls on a reference.</li>
<li>When passing a reference as a function argument.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">/// `length` only needs `vector` temporarily, so it is borrowed.
fn length(vec_ref: &amp;&amp;Vec&lt;i32&gt;) -&gt; usize {
    // vec_ref is auto-dereferenced when you call methods on it.
    vec_ref.len()
}

fn main() {
    let vector = vec![];
    length(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;vector);
}</code></pre></pre>
<hr />
<h2 id="borrowing-6"><a class="header" href="#borrowing-6">Borrowing</a></h2>
<ul>
<li>You will have to dereference variables...
<ul>
<li>When writing into them.</li>
<li>And other times that usage may be ambiguous.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 5;
let ref_a = &amp;mut a;
*ref_a = 4;
println!(&quot;{}&quot;, *ref_a + 4);
// ==&gt; 8
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="ref"><a class="header" href="#ref"><code>ref</code></a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vector = vec![0];

{
      // These are equivalent
      let ref1 = &amp;vector;
      let ref ref2 = vector;
      assert_eq!(ref1, ref2);
}

let ref mut ref3 = vector;
ref3.push(1);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>When binding a variable, <code>ref</code> can be applied to make the variable a reference to the assigned value.
<ul>
<li>Take a mutable reference with <code>ref mut</code>.</li>
</ul>
</li>
<li>This is most useful in <code>match</code> statements when destructuring patterns.</li>
</ul>
<hr />
<h2 id="ref-1"><a class="header" href="#ref-1"><code>ref</code></a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vectors = (vec![0], vec![1]);
match vectors {
    (ref v1, ref mut v2) =&gt; {
        v1.len();
        v2.push(2);
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Use <code>ref</code> and <code>ref mut</code> when binding variables inside match statements.</li>
</ul>
<hr />
<h2 id="copy-types"><a class="header" href="#copy-types"><code>Copy</code> Types</a></h2>
<ul>
<li>Rust defines a trait¹ named <code>Copy</code> that signifies that a type may be
copied instead whenever it would be moved.</li>
<li>Most primitive types are <code>Copy</code> (<code>i32</code>, <code>f64</code>, <code>char</code>, <code>bool</code>, etc.)</li>
<li>Types that contain references may not be <code>Copy</code> (e.g. <code>Vec</code>, <code>String</code>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 12;
let y = x; // `i32` is `Copy`, so it's not moved :D
println!(&quot;x still works: {}, and so does y: {}&quot;, x, y);
<span class="boring">}</span></code></pre></pre>
<p>¹ Like a Java interface or Haskell typeclass</p>
<p>???</p>
<p>This is why we've been using Vectors as examples in this slide set.</p>
<hr />
<h2 id="borrowing-rules"><a class="header" href="#borrowing-rules">Borrowing Rules</a></h2>
<h5 id="the-holy-grail-of-rust"><a class="header" href="#the-holy-grail-of-rust"><em>The Holy Grail of Rust</em></a></h5>
<p>Learn these rules, and they will serve you well.</p>
<ul>
<li>You can't keep borrowing something after it stops existing.</li>
<li>One object may have many immutable references to it (<code>&amp;T</code>).</li>
<li><strong>OR</strong> <em>exactly one</em> mutable reference (<code>&amp;mut T</code>) (not both).</li>
<li>That's it!</li>
</ul>
<p><img src="img/holy-grail.jpg" alt="" /></p>
<hr />
<h3 id="borrowing-prevents"><a class="header" href="#borrowing-prevents">Borrowing Prevents...</a></h3>
<ul>
<li>Iterator invalidation due to mutating a collection you're iterating over.</li>
<li>This pattern can be written in C, C++, Java, Python, Javascript...
<ul>
<li>But may result in, e.g, <code>ConcurrentModificationException</code> (at runtime!)</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vs = vec![1,2,3,4];
for v in &amp;vs {
    vs.pop();
    // ERROR: cannot borrow `vs` as mutable because
    // it is also borrowed as immutable
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>pop</code> needs to borrow <code>vs</code> as mutable in order to modify the data.</li>
<li>But <code>vs</code> is being borrowed as immutable by the loop!</li>
</ul>
<hr />
<h3 id="borrowing-prevents-1"><a class="header" href="#borrowing-prevents-1">Borrowing Prevents...</a></h3>
<ul>
<li>Use-after-free</li>
<li>Valid in C, C++...</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y: &amp;i32;
{
    let x = 5;
    y = &amp;x; // error: `x` does not live long enough
}
println!(&quot;{}&quot;, *y);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The full error message:</li>
</ul>
<pre><code>error: `x` does not live long enough
note: reference must be valid for the block suffix following statement
    0 at 1:16
...but borrowed value is only valid for the block suffix
    following statement 0 at 4:18
</code></pre>
<ul>
<li>This eliminates a <em>huge</em> number of memory safety bugs <em>at compile time</em>.</li>
</ul>
<p>???</p>
<p>As a side note, this technique of creating a block to limit the scope of a
variable (in this case x) is pretty useful.</p>
<hr />
<h2 id="example-vectors"><a class="header" href="#example-vectors">Example: Vectors</a></h2>
<ul>
<li>You can iterate over <code>Vec</code>s in three different ways:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vs = vec![0,1,2,3,4,5,6];

// Borrow immutably
for v in &amp;vs { // Can also write `for v in vs.iter()`
    println!(&quot;I'm borrowing {}.&quot;, v);
}

// Borrow mutably
for v in &amp;mut vs { // Can also write `for v in vs.iter_mut()`
    *v = *v + 1;
    println!(&quot;I'm mutably borrowing {}.&quot;, v);
}

// Take ownership of the whole vector
for v in vs { // Can also write `for v in vs.into_iter()`
    println!(&quot;I now own {}! AHAHAHAHA!&quot;, v);
}

// `vs` is no longer valid
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
