<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tour of Rust - KUOSC Rust Workshop</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="why_rust.html"><strong aria-hidden="true">2.</strong> Why Rust?</a></li><li class="chapter-item expanded "><a href="Installing_Rust.html"><strong aria-hidden="true">3.</strong> Installing Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setting_up.html"><strong aria-hidden="true">3.1.</strong> Setting Up Editors and Extensions</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="dissect-hello-world.html"><strong aria-hidden="true">3.3.</strong> Understanding Hello world</a></li></ol></li><li class="chapter-item expanded "><a href="c-dilemma.html"><strong aria-hidden="true">4.</strong> Comparing with C</a></li><li class="chapter-item expanded "><a href="tour_of_rust.html" class="active"><strong aria-hidden="true">5.</strong> Tour of Rust</a></li><li class="chapter-item expanded "><a href="stack-vs-heap.html"><strong aria-hidden="true">6.</strong> Stack vs Heap</a></li><li class="chapter-item expanded "><a href="ownership-and-borrow-check.html"><strong aria-hidden="true">7.</strong> Ownership and Borrow Checker</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Work in Progress</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">KUOSC Rust Workshop</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Some snippets that will help you understand Rust code and some Rust fundamentals along the way</p>
<p><code>let</code> introduces variable binding.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 42; 
<span class="boring">}</span></code></pre></pre>
<p>Since Rust is statically typed language, which means you have to specify the type of variable. i.e if it is storing strings, or integers or floating numbers or your own data type</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let a: i32 = 12; // 32 bit integer 
let b: &amp;str = &quot;Hello nepal&quot;;  //str
let c: char = 'a'; //char
let d: bool = true;
let e: f32 = 3.1415;
let c: u32 = 32; //32 bit integer but you can't store negative numbers
<span class="boring">}</span></code></pre></pre>
<p>Rust can implicitly identify your variable type based upon the content you are passing to variable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 12; // automatically assigned to i32
<span class="boring">}</span></code></pre></pre>
<p>To print something to console, you just use </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello world&quot;);
<span class="boring">}</span></code></pre></pre>
<p>to print the contents of the variable you can</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let age : i32 = 21;
println!(&quot;Hello, my age is {}&quot;, age);
// or you can also 
println!(&quot;Hello, my age is {age}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Notice that exclamation mark at the end. it means it is <a href="Rust%20macros.html">Rust macros</a> . </p>
<p>Rust variables are immutable by default which means, you can't change the content of the variable once you assign something to it. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let age : i32 = 21;
age = 22; // error this won't work, because age is immutable
<span class="boring">}</span></code></pre></pre>
<p>You can shadow a variable bindings</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 17;
let x = &quot;awesome&quot;; // x is not mutable, but we re-binded it
<span class="boring">}</span></code></pre></pre>
<p>You can also use patterns to declare variables</p>
<pre><code>let (a,b) = (&quot;Nepal GPO sucks&quot;,12);
</code></pre>
<p>You have to explicitly use the keyword <code>mut</code> to make it re-assignable</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut age: i32 = 21;
age = 22; // valid because we used mut keyword
<span class="boring">}</span></code></pre></pre>
<p>Now similarly generate small snippets and information combination for
conditionals, loops, match, struct, vector, array, tuples and so on</p>
<h4 id="comments"><a class="header" href="#comments">Comments</a></h4>
<pre><code>/// Triple-slash comments are docstring comments.
///
/// `rustdoc` uses docstring comments to generate
/// documentation, and supports **Markdown** formatting.
fn foo() {
    // Double-slash comments are normal.

    /* Block comments
     * also exist /* and can be nested! */
     */
}
</code></pre>
<h4 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h4>
<p>In Rust, you can use <code>if</code>, <code>else if</code>, and <code>else</code> statements for conditionals.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 7;

if number &lt; 5 {
    println!(&quot;Condition is true&quot;);
} else if number == 7 {
    println!(&quot;Number is seven&quot;);
} else {
    println!(&quot;Condition is false&quot;);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="arrays"><a class="header" href="#arrays">Arrays</a></h4>
<ul>
<li>Arrays are generically of type <code>[T; N]</code>.
<ul>
<li>T is type, can be &amp;str, char, bool, i32 etc</li>
<li>N is a compile-time <em>constant</em>. Arrays cannot be resized.</li>
<li>Array access is bounds-checked at runtime.</li>
</ul>
</li>
<li>Arrays are indexed with <code>[]</code> 
<ul>
<li><code>arr[3]</code> gives you the 4th element of <code>arr</code></li>
</ul>
</li>
</ul>
<pre><code>let arr1 = [1, 2, 3]; // (array of 3 elements)
let arr2 = [2; 32];   // (array of 32 `2`s)
let arr2: [u8;4] = [12,32,73,11]; // (array of 4 8-bit integers that can only accept positive numbers)
</code></pre>
<h4 id="slices"><a class="header" href="#slices">Slices</a></h4>
<p>You create a slice of array and it is in format &amp;[T]. They are reference to your arrays, and you can take specific section of your arrays with slices too. </p>
<pre><code>let arr = [0, 1, 2, 3, 4, 5];
let total_slice = &amp;arr;         // Slice all of `arr`
let total_slice = &amp;arr[..];     // Same, but more explicit
let partial_slice = &amp;arr[2..5]; // [2, 3, 4]
</code></pre>
<h4 id="strings"><a class="header" href="#strings">Strings</a></h4>
<p>There are two types of strings.<code>String</code> and <code>&amp;str</code>. Strings are growable set of characters. Basically you can think of it as dynamic array of characters. <code>&amp;str</code> is the slice of <code>String</code> which means they are fixed. For more information look to <a href="stack%20vs%20heap.html">stack vs heap</a>, to understand the difference between String and &amp;str. </p>
<p>When you use literals in your program, compiler automatically assumes it is of type <code>&amp;str</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = &quot;Nepal's General post office is why i hate government work&quot;;
// this is of type &amp;str 

let b = String::from(&quot;Foo&quot;); //this is of type String
let s4: &amp;str = &amp;b; 
<span class="boring">}</span></code></pre></pre>
<h4 id="vector"><a class="header" href="#vector">Vector</a></h4>
<p><code>Vec&lt;T&gt;</code> are resizable arrays. <code>&lt;T&gt;</code> denotes the generic type, so we pass the type from there. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v: Vec&lt;i32&gt; = Vec::new(); // Declare a new vector

v.push(5);
v.push(6);
v.push(7);
<span class="boring">}</span></code></pre></pre>
<p>Shortcut method to create vector</p>
<pre><code>let v2 = vec![1,2,3];
</code></pre>
<p>Vectors can be indexed with <code>[]</code>, but you have to use <code>usize</code>.</p>
<pre><code>let v2 = vec![1,2,3];
let i: u8 = 2;
// let d = v2[i]; // error as i should be of type usize
let d = v2[i as usize]; // casting
</code></pre>
<h4 id="loops"><a class="header" href="#loops">Loops</a></h4>
<p>Rust provides several types of loops, including <code>loop</code>, <code>while</code>, and <code>for</code>.</p>
<p>Infinite Loop</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    println!(&quot;This will loop forever until explicitly broken!&quot;);
    break; // Use break to exit the loop
}
<span class="boring">}</span></code></pre></pre>
<h4 id="while-loop"><a class="header" href="#while-loop">While Loop</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut count = 0;

while count &lt; 5 {
    println!(&quot;count: {}&quot;, count);
    count += 1;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="for-loop"><a class="header" href="#for-loop">For Loop</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for number in 1..4 { // 1..4 is a range (1,2,3)
    println!(&quot;number: {}&quot;, number);
	// you can break and continue too
}

<span class="boring">}</span></code></pre></pre>
<p>notice that <code>1..4</code>. It is a range. The syntax is <code>start..end</code> , Some operation on ranges</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	// including all the endpoints of range
	let include_all = (1..=4); // 1,2,3,4 

	// reversing
	let reversed = (1..4).rev(); // 3,2,1

	// convert range to vector
	let numbers = (1..4).collect::&lt;i32&gt;(); // collect 1,2,3,4 as 32 bit integer 
	// or
	let numbers: Vec&lt;i32&gt; = (1..4).collect();

	//skip
	let skipped_val = (1..10).skip(2);  //1,3,5,7,9

	// explore enumerate(), iter(), take() by yourself
<span class="boring">}</span></code></pre></pre>
<h2 id="everything-is-expressions-almost"><a class="header" href="#everything-is-expressions-almost">Everything is expressions (almost)</a></h2>
<p>Expressions return a value. So Expressions are something that returns value, can't get simpler than that.<br />
We can bind many things to variable name, because everything is expression. The rule is, if it's expression then we can bind it to a variable.</p>
<pre><code>let x = -5;
let y = if x &gt; 0 { &quot;greater&quot; } else { &quot;less&quot; };
println!(&quot;x = {} is {} than zero&quot;, x, y);
</code></pre>
<h4 id="struct"><a class="header" href="#struct">Struct</a></h4>
<p>Structs are used to create custom data types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

let user1 = User {
    email: String::from(&quot;coldplay@gmail.com&quot;),
    username: String::from(&quot;yellow&quot;),
    active: true,
    sign_in_count: 1,
};
<span class="boring">}</span></code></pre></pre>
<h4 id="tuples"><a class="header" href="#tuples">Tuples</a></h4>
<p>Tuples are fixed-size collections of multiple types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, f64, u8) = (500, 6.4, 1);

let (x, y, z) = tup; // Destructuring

println!(&quot;The value of y is: {}&quot;, y);
<span class="boring">}</span></code></pre></pre>
<h4 id="functions"><a class="header" href="#functions">Functions</a></h4>
<p>Functions in Rust are defined using the <code>fn</code> keyword, with typed parameters and an optional return type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn square(n: i32) -&gt; i32 {
    n * n // no need to type return 
    // if there is no semicolon at the end then it means it returns that value
}

fn squareish(n: i32) -&gt; i32 {
    if n &lt; 5 { return n; } // if you want to return early then use return keyword
    n * n
}

fn greet(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}

greet(&quot;Alice&quot;);
<span class="boring">}</span></code></pre></pre>
<p>You can store functions in variable</p>
<pre><code>let x : fn(i32) -&gt; i32 = square;

fn do_it_two_times(f: &amp;fn(i32) -&gt; i32, x: i32 ) -&gt; i32 {
	f(f(x))
}

let y = do_it_two_times(&amp;square, 5);
</code></pre>
<h4 id="match"><a class="header" href="#match">Match</a></h4>
<p><code>match</code> is similar to switch cases in other languages, but more powerful.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 2;

match number {
    1 =&gt; println!(&quot;One&quot;),
    2 =&gt; println!(&quot;Two&quot;),
    3 =&gt; println!(&quot;Three&quot;),
    _ =&gt; println!(&quot;Anything else&quot;), // '_' is the default case
}
<span class="boring">}</span></code></pre></pre>
<p>you can match with range</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 13;

match number {
    1..=5 =&gt; println!(&quot;It's between 1 and 5&quot;),
    6..=10 =&gt; println!(&quot;It's between 6 and 10&quot;),
    _ =&gt; println!(&quot;It's something else&quot;),
}
<span class="boring">}</span></code></pre></pre>
<p>you can add guards to match</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 4;

match number {
    n if n % 2 == 0 =&gt; println!(&quot;Even number&quot;),
    n if n % 2 != 0 =&gt; println!(&quot;Odd number&quot;),
    _ =&gt; println!(&quot;It's something else&quot;),
}

<span class="boring">}</span></code></pre></pre>
<p>you can match with Enums too, see below examples</p>
<h4 id="enums"><a class="header" href="#enums">Enums</a></h4>
<p>Enums are a way to define a type by enumerating its possible values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Direction {
    Up,
    Down,
    Left,
    Right,
}

fn move_direction(direction: Direction) {
    match direction {
        Direction::Up =&gt; println!(&quot;Moving up&quot;),
        // Other directions...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Enums in Rust can also have data associated with their variants. This feature can be particularly useful for representing more complex scenarios like error handling or state management.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum AppState {
    Loading,
    Content(String),
    Error(String),
}

fn get_app_state(loading: bool, has_error: bool) -&gt; AppState {
    if loading {
        AppState::Loading
    } else if has_error {
        AppState::Error(String::from(&quot;An error occurred&quot;))
    } else {
        AppState::Content(String::from(&quot;Content loaded successfully&quot;))
    }
}

let state = get_app_state(false, true);

match state {
    AppState::Loading =&gt; println!(&quot;App is loading...&quot;),
    AppState::Content(content) =&gt; println!(&quot;Content: {}&quot;, content),
    AppState::Error(error) =&gt; println!(&quot;Error: {}&quot;, error),
}
<span class="boring">}</span></code></pre></pre>
<p>This example shows an <code>AppState</code> enum with different variants for loading, content, and error states. The <code>match</code> statement then handles each state accordingly.</p>
<p>Rust's <code>Option</code> and <code>Result</code> types are actually enums under the hood. Understanding the basic enum concept can help grasp these types better.</p>
<ul>
<li><code>Option&lt;T&gt;</code> can be either <code>Some(T)</code> or <code>None</code>.</li>
<li><code>Result&lt;T, E&gt;</code> can be either <code>Ok(T)</code> for success or <code>Err(E)</code> for an error.</li>
</ul>
<p>Here's a simplified version of how they might be defined:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; {
    if denominator == 0.0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

let result = divide(10.0, 2.0);
<span class="boring">}</span></code></pre></pre>
<p>As written above, <code>Result&lt;T, E&gt;</code> is used for error handling. It returns <code>Ok(value)</code> if successful, or <code>Err(error)</code> if an error occurs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_age(age: i32) -&gt; Result&lt;(), String&gt; {
    if age &gt;= 18 {
        Ok(())
    } else {
        Err(String::from(&quot;Underage&quot;))
    }
}

let age_check = check_age(20);
<span class="boring">}</span></code></pre></pre>
<h4 id="cargo"><a class="header" href="#cargo">Cargo</a></h4>
<ul>
<li>Create a new project:
<ul>
<li><code>cargo new project_name</code> (library)</li>
<li><code>cargo new project_name --bin</code> (executable)</li>
</ul>
</li>
<li>Build your project: <code>cargo build</code></li>
<li>Run your tests: <code>cargo test</code></li>
</ul>
<h4 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h4>
<ul>
<li>This is what Rust uses to manage dependencies and project metadata. When you open something like this is shown</li>
</ul>
<pre><code>[package]
name = &quot;my_project&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
serde = &quot;1.0&quot;
serde_json = &quot;1.0&quot;
log = &quot;0.4&quot;

</code></pre>
<ul>
<li>You add crates to your project as dependency</li>
</ul>
<pre><code>[dependencies] 
futures = &quot;0.3&quot; // name = version
</code></pre>
<ul>
<li><strong>Exact version</strong>: <code>&quot;1.2.3&quot;</code></li>
<li><strong>Caret version requirements</strong>: <code>&quot;^1.2.3&quot;</code> (default, compatible with public API version 1.2.3)</li>
<li><strong>Tilde version requirements</strong>: <code>&quot;~1.2.3&quot;</code> (version 1.2.3 and the versions up to 1.3.0, not including 1.3.0)</li>
<li><strong>Wildcard version requirements</strong>: <code>&quot;1.2.*&quot;</code> (any version that starts with 1.2)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="c-dilemma.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="stack-vs-heap.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="c-dilemma.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="stack-vs-heap.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
