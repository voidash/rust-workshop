<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ownership and Borrow Checker - KUOSC Rust Workshop</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="why_rust.html"><strong aria-hidden="true">2.</strong> Why Rust?</a></li><li class="chapter-item expanded "><a href="Installing_Rust.html"><strong aria-hidden="true">3.</strong> Installing Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setting_up.html"><strong aria-hidden="true">3.1.</strong> Setting Up Editors and Extensions</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="dissect-hello-world.html"><strong aria-hidden="true">3.3.</strong> Understanding Hello world</a></li></ol></li><li class="chapter-item expanded "><a href="c-dilemma.html"><strong aria-hidden="true">4.</strong> Comparing with C</a></li><li class="chapter-item expanded "><a href="tour_of_rust.html"><strong aria-hidden="true">5.</strong> Tour of Rust</a></li><li class="chapter-item expanded "><a href="stack-vs-heap.html"><strong aria-hidden="true">6.</strong> Stack vs Heap</a></li><li class="chapter-item expanded "><a href="ownership-and-borrow-check.html" class="active"><strong aria-hidden="true">7.</strong> Ownership and Borrow Checker</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Work in Progress</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">KUOSC Rust Workshop</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>Any variable that binds some value to it takes ownership of that data. This basically means a peice of data can only have one owner at a time.</p>
<h4 id="ownership-is-rust-claim-to-fame"><a class="header" href="#ownership-is-rust-claim-to-fame">Ownership is Rust claim to fame</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    // Creates a Vec object.
    // Gives ownership of the Vec object to v1.
    let mut v1 = vec![1, 2, 3];

    v1.pop();
    v1.push(4);

    // At the end of the scope, v1 goes out of scope.
    // v1 still owns the Vec object, so it can be cleaned up.
}

<span class="boring">}</span></code></pre></pre>
<h2 id="why-discuss-ownership-in-the-first-place"><a class="header" href="#why-discuss-ownership-in-the-first-place">Why discuss ownership in the first place?</a></h2>
<p>If you boil down everything you do with a programming language , then all you do is define &quot;ways to interact with data&quot;. At the core, programming languages are different on the basis of syntax and how they handle your data, how much it trusts you with the data or it questions your memory management skills. The region where your data is stored is Memory. Some language like C++, C and Rust can give access low level access to Memory Region, whereas some languages like Javascript, Python can't provide you with same level of access because the memory management is not up to you. </p>
<ul>
<li>Languages like Java, Javascript use something called garbage collector which allows you instantiate or store data in memory but when it comes to cleaning it up once it is of no use then the garbage collector will help you cleaning up.</li>
</ul>
<h4 id="garbage-collection-is-expensive"><a class="header" href="#garbage-collection-is-expensive">Garbage collection is expensive.</a></h4>
<p>Garbage collector(<strong>GC</strong>) is also a piece of code, that cleans up your mess, which means when you build your executable file, the GC code also has to be included. It also has to check from time to time if certain data can be freed or not. That constant checking and cleaning is a overhead, that makes your program slow. The extra code that you include is also overhead that makes your program size large. </p>
<h2 id="manual-memory-management"><a class="header" href="#manual-memory-management">Manual Memory management</a></h2>
<p>programming languages like C, C++ allow you to do your manual memory management. It completely trusts the developer. But this introduces problems. When a piece of memory that needed to be freed is not freed then there is memory leakage. Or what if we delete a piece of memory before it is used? It will lead to Dangling pointers. those pointers will assume that they still have correct data in memory. It is not memory safe</p>
<h2 id="rust-to-the-rescue"><a class="header" href="#rust-to-the-rescue">Rust to the rescue</a></h2>
<p>Ownership is Rust’s most unique feature and has deep implications for the rest of the language. It enables Rust to make memory safety guarantees without needing a garbage collector, so it’s important to understand how ownership works.</p>
<h2 id="read-about-stack-vs-heap"><a class="header" href="#read-about-stack-vs-heap"><a href="./stack-vs-heap.html">Read about Stack vs Heap </a></a></h2>
<h2 id="compile-time-and-run-time"><a class="header" href="#compile-time-and-run-time">Compile Time and Run Time</a></h2>
<p>Compile time is when your code is being converted to executable format.
Runtime is when your executable is being run.</p>
<ul>
<li>When you introduce a variable binding, it takes ownership of its data. And a piece of data can only have one owner at a time.</li>
<li>When a variable binding goes out of scope, nothing has access to the data anymore, so it can be released. Which means, if it's on the heap, it can be de-allocated.</li>
<li>And data must be guaranteed to outlive its references. Or, all references are guaranteed to be valid.</li>
</ul>
<h2 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h2>
<pre><code>let v1 = vec![1, 2, 3];

// Ownership of the Vec object moves to v2.
let v2 = v1;

println!(&quot;{}&quot;, v1[2]); // error: use of moved value `v1`
</code></pre>
<ul>
<li>
<p><code>let v2 = v1;</code></p>
<ul>
<li>We don't want to copy the data, since that's expensive.</li>
<li>The data cannot have multiple owners.</li>
<li>Solution: move the Vec's ownership into v2, and declare v1 invalid.</li>
</ul>
</li>
<li>
<p><code>println!(&quot;{}&quot;, v1[2]);</code>
We know that v1 is no longer a valid variable binding, so this is an error.
Rust can reason about this at compile time, so it throws a compiler error.</p>
</li>
</ul>
<p>Here's another example:</p>
<ul>
<li>Line 1: declare a vector v1.</li>
<li>Line 2: let v2 = v1. Ownership of the vector is moved from v1 to v2.
<ul>
<li>we don't want to move or copy the data, that's expensive and causes other
bugs</li>
<li>we already know the data can't have multiple owners</li>
</ul>
</li>
<li>Line 3: try to print v1.
<ul>
<li>but since the vector has been moved out of v1, it is no longer a valid
variable binding</li>
</ul>
</li>
<li>all of this happens at compile time.</li>
</ul>
<hr />
<h2 id="move-semantics-1"><a class="header" href="#move-semantics-1">Move Semantics</a></h2>
<ul>
<li>
<p>Moving ownership is a compile-time semantic; it doesn't involve moving data
during your program.</p>
</li>
<li>
<p>Moves are automatic (via assignments); no need to use something like C++'s
<code>std::move</code>.</p>
<ul>
<li>However, there are functions like <code>std::mem::replace</code> in Rust to provide
advanced ownership management.</li>
</ul>
</li>
<li>
<p>Moving ownership is an impliict operation done at compile time. No data is
moved or copied around when your program is being run.</p>
</li>
<li>
<p>The movement of data is automatic, you don't need to call anything like
std::move (as in C++).</p>
</li>
<li>
<p>But you can do more fine-grained ownership or memory movement with a number of
standrard library functions, like std::mem::replace.</p>
</li>
</ul>
<hr />
<h2 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h2>
<ul>
<li>Ownership does not always have to be moved.</li>
<li>What would happen if it did? Rust would get very tedious to write:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn vector_length(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // Do whatever here,
    // then return ownership of `v` back to the caller
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>You could imagine that this does not scale well either.
<ul>
<li>The more variables you had to hand back, the longer your return type would be!</li>
<li>Imagine having to pass ownership around for 5+ variables at a time :(</li>
</ul>
</li>
</ul>
<p>???</p>
<ul>
<li>Ownership doesn't have to be moved.</li>
<li>If it did, you would also have to return ownership at the end of every
function, or have all of your variables constantly going out of scope.</li>
<li>This gets absurd very quickly, imagine having to return all of your function
arguments as return values just to make sure they don't go out of scope.</li>
</ul>
<hr />
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<ul>
<li>Obviously, this is not the case.</li>
<li>Instead of transferring ownership, we can <em>borrow</em> data.</li>
<li>A variable's data can be borrowed by taking a reference to the variable;
ownership doesn't change.
<ul>
<li>When a reference goes out of scope, the borrow is over.</li>
<li>The original variable retains ownership throughout.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

// v_ref is a reference to v.
let v_ref = &amp;v;

// use v_ref to access the data in the vector v.
assert_eq!(v[1], v_ref[1]);
<span class="boring">}</span></code></pre></pre>
<p>???</p>
<ul>
<li>Obviously, this is not the case in Rust, otherwise the language would be
impossible to use.</li>
<li>Instead, we can temporarily transfer ownership by borrowing data.</li>
<li>The way that borrowing works is: you can take a reference to the original
variable and use it to access the data.</li>
<li>When a reference goes out of scope, the borrow is over.</li>
<li>However, the original variable retains ownership during the borrow and
afterwards.</li>
</ul>
<hr />
<h2 id="borrowing-1"><a class="header" href="#borrowing-1">Borrowing</a></h2>
<ul>
<li>Caveat: this adds restrictions to the original variable.</li>
<li>Ownership cannot be transferred from a variable while references to it exist.
<ul>
<li>That would invalidate the reference.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

// v_ref is a reference to v.
let v_ref = &amp;v;

// Moving ownership to v_new would invalidate v_ref.
// error: cannot move out of `v` because it is borrowed
let v_new = v;
<span class="boring">}</span></code></pre></pre>
<p>???</p>
<ul>
<li>This adds a caveat: ownership cannot be ransferred <em>from</em> a variable that is
currently being borrowed, because that would invalidate the reference.</li>
</ul>
<hr />
<h2 id="borrowing-2"><a class="header" href="#borrowing-2">Borrowing</a></h2>
<pre><pre class="playground"><code class="language-rust">/// `length` only needs `vector` temporarily, so it is borrowed.
fn length(vec_ref: &amp;Vec&lt;i32&gt;) -&gt; usize {
    // vec_ref is auto-dereferenced when you call methods on it.
    vec_ref.len()
    // you can also explicitly dereference.
    // (*vec_ref).len()
}

fn main() {
    let vector = vec![];
    length(&amp;vector);
    println!(&quot;{:?}&quot;, vector); // this is fine
}</code></pre></pre>
<ul>
<li>Note the type of <code>length</code>: <code>vec_ref</code> is passed by reference, so it's now an <code>&amp;Vec&lt;i32&gt;</code>.</li>
<li>References, like bindings, are <em>immutable</em> by default.</li>
<li>The borrow is over after the reference goes out of scope (at the end of <code>length</code>).</li>
</ul>
<hr />
<h2 id="borrowing-3"><a class="header" href="#borrowing-3">Borrowing</a></h2>
<pre><pre class="playground"><code class="language-rust">/// `push` needs to modify `vector` so it is borrowed mutably.
fn push(vec_ref: &amp;mut Vec&lt;i32&gt;, x: i32) {
    vec_ref.push(x);
}

fn main() {
    let mut vector: Vec&lt;i32&gt; = vec![];
    let vector_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut vector;
    push(vector_ref, 4);
}</code></pre></pre>
<ul>
<li>Variables can be borrowed by <em>mutable</em> reference: <code>&amp;mut vec_ref</code>.
<ul>
<li><code>vec_ref</code> is a reference to a mutable <code>Vec</code>.</li>
<li>The type is <code>&amp;mut Vec&lt;i32&gt;</code>, not <code>&amp;Vec&lt;i32&gt;</code>.</li>
</ul>
</li>
<li>Different from a reference which is variable.</li>
</ul>
<hr />
<h2 id="borrowing-4"><a class="header" href="#borrowing-4">Borrowing</a></h2>
<pre><pre class="playground"><code class="language-rust">/// `push` needs to modify `vector` so it is borrowed mutably.
fn push2(vec_ref: &amp;mut Vec&lt;i32&gt;, x: i32) {
    // error: cannot move out of borrowed content.
    let vector = *vec_ref;
    vector.push(x);
}

fn main() {
    let mut vector = vec![];
    push2(&amp;mut vector, 4);
}</code></pre></pre>
<ul>
<li>Error! You can't dereference <code>vec_ref</code> into a variable binding because that
would change the ownership of the data.</li>
</ul>
<hr />
<h2 id="borrowing-5"><a class="header" href="#borrowing-5">Borrowing</a></h2>
<ul>
<li>Rust will auto-dereference variables...
<ul>
<li>When making method calls on a reference.</li>
<li>When passing a reference as a function argument.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">/// `length` only needs `vector` temporarily, so it is borrowed.
fn length(vec_ref: &amp;&amp;Vec&lt;i32&gt;) -&gt; usize {
    // vec_ref is auto-dereferenced when you call methods on it.
    vec_ref.len()
}

fn main() {
    let vector = vec![];
    length(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;vector);
}</code></pre></pre>
<hr />
<h2 id="borrowing-6"><a class="header" href="#borrowing-6">Borrowing</a></h2>
<ul>
<li>You will have to dereference variables...
<ul>
<li>When writing into them.</li>
<li>And other times that usage may be ambiguous.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 5;
let ref_a = &amp;mut a;
*ref_a = 4;
println!(&quot;{}&quot;, *ref_a + 4);
// ==&gt; 8
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="ref"><a class="header" href="#ref"><code>ref</code></a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vector = vec![0];

{
      // These are equivalent
      let ref1 = &amp;vector;
      let ref ref2 = vector;
      assert_eq!(ref1, ref2);
}

let ref mut ref3 = vector;
ref3.push(1);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>When binding a variable, <code>ref</code> can be applied to make the variable a reference to the assigned value.
<ul>
<li>Take a mutable reference with <code>ref mut</code>.</li>
</ul>
</li>
<li>This is most useful in <code>match</code> statements when destructuring patterns.</li>
</ul>
<hr />
<h2 id="ref-1"><a class="header" href="#ref-1"><code>ref</code></a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vectors = (vec![0], vec![1]);
match vectors {
    (ref v1, ref mut v2) =&gt; {
        v1.len();
        v2.push(2);
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Use <code>ref</code> and <code>ref mut</code> when binding variables inside match statements.</li>
</ul>
<hr />
<h2 id="copy-types"><a class="header" href="#copy-types"><code>Copy</code> Types</a></h2>
<ul>
<li>Rust defines a trait¹ named <code>Copy</code> that signifies that a type may be
copied instead whenever it would be moved.</li>
<li>Most primitive types are <code>Copy</code> (<code>i32</code>, <code>f64</code>, <code>char</code>, <code>bool</code>, etc.)</li>
<li>Types that contain references may not be <code>Copy</code> (e.g. <code>Vec</code>, <code>String</code>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 12;
let y = x; // `i32` is `Copy`, so it's not moved :D
println!(&quot;x still works: {}, and so does y: {}&quot;, x, y);
<span class="boring">}</span></code></pre></pre>
<p>¹ Like a Java interface or Haskell typeclass</p>
<p>???</p>
<p>This is why we've been using Vectors as examples in this slide set.</p>
<hr />
<h2 id="borrowing-rules"><a class="header" href="#borrowing-rules">Borrowing Rules</a></h2>
<h5 id="the-holy-grail-of-rust"><a class="header" href="#the-holy-grail-of-rust"><em>The Holy Grail of Rust</em></a></h5>
<p>Learn these rules, and they will serve you well.</p>
<ul>
<li>You can't keep borrowing something after it stops existing.</li>
<li>One object may have many immutable references to it (<code>&amp;T</code>).</li>
<li><strong>OR</strong> <em>exactly one</em> mutable reference (<code>&amp;mut T</code>) (not both).</li>
<li>That's it!</li>
</ul>
<p><img src="img/holy-grail.jpg" alt="" /></p>
<hr />
<h3 id="borrowing-prevents"><a class="header" href="#borrowing-prevents">Borrowing Prevents...</a></h3>
<ul>
<li>Iterator invalidation due to mutating a collection you're iterating over.</li>
<li>This pattern can be written in C, C++, Java, Python, Javascript...
<ul>
<li>But may result in, e.g, <code>ConcurrentModificationException</code> (at runtime!)</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vs = vec![1,2,3,4];
for v in &amp;vs {
    vs.pop();
    // ERROR: cannot borrow `vs` as mutable because
    // it is also borrowed as immutable
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>pop</code> needs to borrow <code>vs</code> as mutable in order to modify the data.</li>
<li>But <code>vs</code> is being borrowed as immutable by the loop!</li>
</ul>
<hr />
<h3 id="borrowing-prevents-1"><a class="header" href="#borrowing-prevents-1">Borrowing Prevents...</a></h3>
<ul>
<li>Use-after-free</li>
<li>Valid in C, C++...</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y: &amp;i32;
{
    let x = 5;
    y = &amp;x; // error: `x` does not live long enough
}
println!(&quot;{}&quot;, *y);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The full error message:</li>
</ul>
<pre><code>error: `x` does not live long enough
note: reference must be valid for the block suffix following statement
    0 at 1:16
...but borrowed value is only valid for the block suffix
    following statement 0 at 4:18
</code></pre>
<ul>
<li>This eliminates a <em>huge</em> number of memory safety bugs <em>at compile time</em>.</li>
</ul>
<p>???</p>
<p>As a side note, this technique of creating a block to limit the scope of a
variable (in this case x) is pretty useful.</p>
<hr />
<h2 id="example-vectors"><a class="header" href="#example-vectors">Example: Vectors</a></h2>
<ul>
<li>You can iterate over <code>Vec</code>s in three different ways:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vs = vec![0,1,2,3,4,5,6];

// Borrow immutably
for v in &amp;vs { // Can also write `for v in vs.iter()`
    println!(&quot;I'm borrowing {}.&quot;, v);
}

// Borrow mutably
for v in &amp;mut vs { // Can also write `for v in vs.iter_mut()`
    *v = *v + 1;
    println!(&quot;I'm mutably borrowing {}.&quot;, v);
}

// Take ownership of the whole vector
for v in vs { // Can also write `for v in vs.into_iter()`
    println!(&quot;I now own {}! AHAHAHAHA!&quot;, v);
}

// `vs` is no longer valid
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="stack-vs-heap.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="stack-vs-heap.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
